#!/usr/bin/env node
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

// jshint node: true
'use strict';

var path = require('path');
var url = require('url');
var hyd = require('hydrolysis');
var dom5 = require('dom5');
var constants = require('../lib/constants.js');
var matchers = require('../lib/matchers.js');
var pathResolver = require('../lib/pathresolver.js');

var loader = new hyd.loader();
loader.addResolver(new hyd.fsResolver({}));

function isUniqueImport(importNode) {
  return Boolean(importNode.href);
}

function reparent(newParent) {
  return function(node) {
    node.parentNode = newParent;
  };
}

function remove(node) {
  var parent = node.parentNode;
  if (parent) {
    var idx = parent.childNodes.indexOf(node);
    if (idx > -1) {
      parent.childNodes.splice(idx, 1);
    }
  }
}

function flatten(tree) {
  var doc = tree.html.ast;
  var imports = tree.imports;
  var head = dom5.query(doc, matchers.head);
  var body = dom5.query(doc, matchers.body);
  var importNodes = tree.html.import;
  var importDoc, importHead, importBody, importHeadChildren, importBodyChildren;
  if (imports) {
    for (var i = 0, im; i < imports.length; i++) {
      im = imports[i];
      if (!isUniqueImport(im)) {
        remove(importNodes[i]);
        continue;
      }
      importDoc = flatten(im);
      importHead = dom5.query(importDoc, matchers.head);
      importBody = dom5.query(importDoc, matchers.body);
      // rewrite urls
      pathResolver.resolvePaths(importDoc, im.href, tree.href);
      // merge head and body tags for imports into main document
      importHeadChildren = importHead.childNodes;
      importBodyChildren = importBody.childNodes;
      importHeadChildren.forEach(reparent(head));
      importBodyChildren.forEach(reparent(body));
      // replace import node with importHeadChildren
      var idx = head.childNodes.indexOf(importNodes[i]);
      head.childNodes = head.childNodes.slice(0, idx).concat(importHeadChildren, head.childNodes.slice(idx + 1));
      // prepend import body to document body
      body.childNodes = importBodyChildren.concat(body.childNodes);
    }
  }
  return doc;
}

var target = process.argv[2];

if (!target) {
  console.error('no target!');
  process.exit(1);
}

loader.request(target).then(function(content) {
  return new hyd.monomers(content, true, target, loader).metadataTree();
}).then(function(tree) {
  var flatDoc = flatten(tree);
  // polymer 0.8 ideal build
  var head = dom5.query(flatDoc, matchers.head);
  var body = dom5.query(flatDoc, matchers.body);
  remove(head);
  remove(body);
  head.childNodes.forEach(reparent(flatDoc));
  body.childNodes.forEach(reparent(flatDoc));
  flatDoc.childNodes = head.childNodes.concat(body.childNodes);
  var scriptNodes = dom5.queryAll(flatDoc, matchers.JS);
  var fullText = scriptNodes.reduce(function(a, b) {
    return a + b.childNodes[0].value;
  }, '');
  scriptNodes.forEach(remove);
  var s = scriptNodes[0];
  s.childNodes[0].value = fullText;
  flatDoc.childNodes.push(s);
  // end
  var serializer = new (require('parse5').Serializer)();
  console.log(serializer.serialize(flatDoc));
}).catch(function(err) {
  console.log(err);
  process.exit(1);
});
